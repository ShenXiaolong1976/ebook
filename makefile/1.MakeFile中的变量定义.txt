GNU make 的主要预定义变量：
预定义变量                      含义
$*              不包含扩展名的目标文件名称。
$+              所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件。
$<              第一个依赖文件的名称。
$?              所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚。
$@              目标的完整名称。
$^              所有的依赖文件，以空格分开，不包含重复的依赖文件。
$%              如果目标是归档成员，则该变量表示目标的归档成员名称。例如，如果目标名称
                为 mytarget.so(image.o)，则 $@ 为 mytarget.so，而 $% 为 image.o。
AR              归档维护程序的名称，默认值为 ar。
ARFLAGS         归档维护程序的选项。
AS              汇编程序的名称，默认值为 as。
ASFLAGS         汇编程序的选项。
CC              C 编译器的名称，默认值为 cc。
CCFLAGS         C 编译器的选项。
CPP             C 预编译器的名称，默认值为 $(CC) -E。
CPPFLAGS        C 预编译的选项。
CXX             C++ 编译器的名称，默认值为 g++。
CXXFLAGS        C++ 编译器的选项。
FC              FORTRAN 编译器的名称，默认值为 f77。
FFLAGS          FORTRAN 编译器的选项。


 MakeFile中的变量定义 收藏 
   一般在我们书写Makefile时，各部分变量引用的格式我们建议如下：
1. make变量（Makefile中定义的或者是make的环境变量）的引用使用“$(VAR)”格式。

2. 出现在规则命令行中shell变量（一般为执行命令过程中的临时变量，它不属于Makefile变量，而是一个shell变量）引用使用shell的“$tmp”格式。
3. 对出现在命令行中的make变量我们同样使用“$(CMDVAR)” 格式来引用。

       MakeFile中给变量赋值有以下两种方式

 

1.递归展开式，使用=直接定义，例子如下：

               foo = $(bar)
               bar = $(ugh)
               ugh = Huh?
               all:;echo $(foo)
  执行“make”将会打印出“Huh?”。整个变量的替换过程时这样的：首先“$(foo)”被替换为“$(bar)”，接下来 “$(bar)”被替换为“$(ugh)”，最后“$(ugh)”被替换为“Hug?”。整个替换的过程是在执行“echo $(foo)”是进行的。

  这种方式的缺点是

           缺点1：使用此风格的变量定义，可能会由于出现变量递归定义而导致make陷入到无限的变量展开过程中，最终使make执行失败.
           缺点2：这种风格的变量定义中如果使用了函数，那么包含在变量值中的函数总会在变量被引用的地方执行（变量被展开时）。

2.直接展开式

这种风格的变量使用“:=”来定义变量。在使用“:=”定义变量时，变量值中对另外变量的引用或者函数的引用在定义时被展开（对变量进行替换）。


x := foo
y := $(x) bar
x := later
就等价于：
y := foo bar
x := later
需要CFLAGS := $(include_dirs) -O
include_dirs := -Ifoo -Ibar
由于在变量“include_dirs”的定义出现在“CFLAGS”定义之后。因此在“CFLAGS”的定义中，“include_dirs”的值为空。“CFLAGS”的值为“-O”而不是“-Ifoo -Ibar -O”。注意的是：此风格变量在定义时就完成了对所引用的变量的展开，因此它不能实现对其后定义变量的引用。

 变量的替换引用,格式为“$(VAR:A=B)”（或者“${VAR:A=B}”），
 意思是，替换变量“VAR”中所有“A”字符结尾的字为“B”结尾的字。
 “结尾”的含义是空格之前（变量值多个字之间使用空格分开）。
 而对于变量其它部分的“A”字符不进行替换。
     自动化变量

$@
代表规则中的目标文件名。如果目标是一个文档（Linux中，一般称.a文件为文档），那么它代表这个文档的文件名。在多目标的模式规则中，它代表的是哪个触发规则被执行的目标文件名。
$%
规则的目标文件是一个静态库文件时，代表静态库的一个成员名。例如，规则的目标是“foo.a(bar.o)”，那么，“$%”的值就为“bar.o”，“$@”的值为“foo.a”。如果目标不是函数库文件，其值为空。
$<
规则的第一个依赖文件名。如果是隐含规则，则它代表通过目标指定的第一个依赖文件。
$?
所有比目标文件更新的依赖文件列表，空格分割。如果目标是静态库文件名，代表的是库成

员（.o文件）的更新情况。
$^
规则的所有依赖文件列表，使用空格分隔。如果目标是静态库文件名，它所代表的只能是所有库成员（.o文件）名。一个文件可重复的出现在目标的依赖中，变量“$^”只记录它的一次引用情况。就是说变量“$^”会去掉重复的依赖文件。
$+
类似“$^”，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时，库的交叉引用场合。

$(@D)
代表目标文件的目录部分（去掉目录部分的最后一个斜杠）。如果“$@”是“dir/foo.o”，那么“$(@D)”的值为“dir”。如果“$@”不存在斜杠，其值就是“.”（当前目录）。注意它和函数“dir”的区别！
$(@F)
目标文件的完整文件名中除目录以外的部分（实际文件名）。如果“$@”为“dir/foo.o”，那么“$(@F)”只就是“foo.o”。“$(@F)”等价于函数“$(notdir $@)”。
$(%D)
$(%F)
当以如“archive(member)”形式静态库为目标时，分别表示库文件成员“member”名中的目录部分和文件名部分。它仅对这种形式的规则目标有效。
$(<D)
$(<F)
分别表示规则中第一个依赖文件的目录部分和文件名部分。
$(^D)
$(^F)
分别表示所有依赖文件的目录部分和文件部分（不存在同一文件）。
$(+D)
$(+F)
分别表示所有依赖文件的目录部分和文件部分（可存在重复文件）。
$(?D)
$(?F)
分别表示被更新的依赖文件的目录部分和文件部分。



本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/wubin1124/archive/2009/07/10/4337794.aspx